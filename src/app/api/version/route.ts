import { NextRequest, NextResponse } from 'next/server';\nimport fs from 'fs';\nimport path from 'path';\n\n/**\n * API Route: /api/version\n * Returns current version information\n */\nexport async function GET(request: NextRequest) {\n  try {\n    // Read version info from config\n    const versionPath = path.join(process.cwd(), 'src/config/version.json');\n    \n    let versionInfo;\n    try {\n      const versionData = fs.readFileSync(versionPath, 'utf8');\n      versionInfo = JSON.parse(versionData);\n    } catch (error) {\n      // Fallback to package.json if version.json doesn't exist\n      const packagePath = path.join(process.cwd(), 'package.json');\n      const packageData = fs.readFileSync(packagePath, 'utf8');\n      const packageJson = JSON.parse(packageData);\n      \n      versionInfo = {\n        version: packageJson.version,\n        buildDate: new Date().toISOString(),\n        commitHash: process.env.VERCEL_GIT_COMMIT_SHA?.slice(0, 7) || 'unknown',\n        features: {\n          linkedin: true,\n          github: true,\n          threejs: true,\n          xr: true,\n          d3: true,\n          performance: true,\n        },\n        apiVersions: {\n          linkedin: 'v2',\n          github: 'v4',\n          vercel: 'v1',\n        },\n        buildInfo: {\n          node: process.version,\n          next: packageJson.dependencies.next || 'unknown',\n          typescript: packageJson.devDependencies.typescript || 'unknown',\n        },\n      };\n    }\n\n    // Add runtime information\n    const runtimeInfo = {\n      ...versionInfo,\n      runtime: {\n        environment: process.env.NODE_ENV || 'development',\n        platform: process.platform,\n        nodeVersion: process.version,\n        uptime: process.uptime(),\n      },\n      deployment: {\n        vercelEnv: process.env.VERCEL_ENV || 'development',\n        vercelRegion: process.env.VERCEL_REGION || 'local',\n        vercelUrl: process.env.VERCEL_URL || 'localhost',\n      },\n    };\n\n    return NextResponse.json(runtimeInfo, {\n      headers: {\n        'Cache-Control': 's-maxage=300, stale-while-revalidate=86400',\n        'X-Portfolio-Version': versionInfo.version,\n        'X-Build-Date': versionInfo.buildDate,\n        'X-Commit-Hash': versionInfo.commitHash,\n      },\n    });\n  } catch (error) {\n    console.error('Failed to get version info:', error);\n    \n    return NextResponse.json(\n      {\n        error: 'Failed to retrieve version information',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * API Route: /api/version (HEAD)\n * Returns version headers without body\n */\nexport async function HEAD(request: NextRequest) {\n  try {\n    const versionPath = path.join(process.cwd(), 'src/config/version.json');\n    const versionData = fs.readFileSync(versionPath, 'utf8');\n    const versionInfo = JSON.parse(versionData);\n\n    return new NextResponse(null, {\n      headers: {\n        'X-Portfolio-Version': versionInfo.version,\n        'X-Build-Date': versionInfo.buildDate,\n        'X-Commit-Hash': versionInfo.commitHash,\n        'X-Features': Object.entries(versionInfo.features)\n          .filter(([_, enabled]) => enabled)\n          .map(([feature, _]) => feature)\n          .join(','),\n      },\n    });\n  } catch (error) {\n    return new NextResponse(null, { status: 500 });\n  }\n}