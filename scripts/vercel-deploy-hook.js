#!/usr/bin/env node\n\n/**\n * Vercel Deployment Integration Hook\n * Handles version synchronization and deployment notifications\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\n\nclass VercelDeploymentHook {\n  constructor() {\n    this.packageJson = this.readPackageJson();\n    this.versionConfig = this.readVersionConfig();\n  }\n\n  readPackageJson() {\n    const packagePath = path.join(__dirname, '../package.json');\n    return JSON.parse(fs.readFileSync(packagePath, 'utf8'));\n  }\n\n  readVersionConfig() {\n    try {\n      const versionPath = path.join(__dirname, '../src/config/version.json');\n      return JSON.parse(fs.readFileSync(versionPath, 'utf8'));\n    } catch (error) {\n      console.warn('Version config not found, using defaults');\n      return null;\n    }\n  }\n\n  writeVersionConfig(config) {\n    const versionPath = path.join(__dirname, '../src/config/version.json');\n    fs.writeFileSync(versionPath, JSON.stringify(config, null, 2) + '\\n');\n  }\n\n  /**\n   * Pre-deployment hook: Update version info for Vercel\n   */\n  async preDeployment() {\n    console.log('üöÄ Running Vercel pre-deployment hook...');\n\n    try {\n      // Update version configuration with deployment info\n      const updatedVersion = {\n        version: this.packageJson.version,\n        buildDate: new Date().toISOString(),\n        commitHash: this.getCommitHash(),\n        features: this.detectFeatures(),\n        apiVersions: {\n          linkedin: this.getLinkedInApiVersion(),\n          github: 'v4',\n          vercel: 'v1',\n        },\n        buildInfo: {\n          node: process.version,\n          next: this.packageJson.dependencies.next || 'unknown',\n          typescript: this.packageJson.devDependencies.typescript || 'unknown',\n        },\n        deployment: {\n          environment: process.env.VERCEL_ENV || 'development',\n          region: process.env.VERCEL_REGION || 'unknown',\n          url: process.env.VERCEL_URL || 'localhost',\n          branch: process.env.VERCEL_GIT_COMMIT_REF || 'unknown',\n          timestamp: new Date().toISOString(),\n        },\n      };\n\n      this.writeVersionConfig(updatedVersion);\n      \n      // Set Vercel environment variables for runtime\n      this.setVercelEnvVars(updatedVersion);\n      \n      // Generate deployment manifest\n      await this.generateDeploymentManifest(updatedVersion);\n      \n      console.log(`‚úÖ Pre-deployment completed for version ${updatedVersion.version}`);\n    } catch (error) {\n      console.error('‚ùå Pre-deployment hook failed:', error);\n      process.exit(1);\n    }\n  }\n\n  /**\n   * Post-deployment hook: Notify and validate deployment\n   */\n  async postDeployment() {\n    console.log('üì° Running Vercel post-deployment hook...');\n\n    try {\n      const deploymentUrl = process.env.VERCEL_URL;\n      const version = this.packageJson.version;\n      \n      // Validate deployment\n      await this.validateDeployment(deploymentUrl);\n      \n      // Update performance metrics\n      await this.updatePerformanceMetrics(deploymentUrl);\n      \n      // Send notifications\n      await this.sendDeploymentNotifications(version, deploymentUrl);\n      \n      console.log(`‚úÖ Post-deployment completed for ${deploymentUrl}`);\n    } catch (error) {\n      console.error('‚ùå Post-deployment hook failed:', error);\n      // Don't exit with error for post-deployment failures\n    }\n  }\n\n  /**\n   * Detect available features in the portfolio\n   */\n  detectFeatures() {\n    const srcPath = path.join(__dirname, '../src');\n    \n    return {\n      linkedin: fs.existsSync(path.join(srcPath, 'components/linkedin-visualizers')),\n      github: fs.existsSync(path.join(srcPath, 'components/github-visualizers')),\n      threejs: this.packageJson.dependencies.hasOwnProperty('@react-three/fiber'),\n      xr: this.packageJson.dependencies.hasOwnProperty('@react-three/xr'),\n      d3: this.packageJson.dependencies.hasOwnProperty('d3'),\n      performance: fs.existsSync(path.join(__dirname, '../.lighthouserc.js')),\n    };\n  }\n\n  /**\n   * Get LinkedIn API version from service file\n   */\n  getLinkedInApiVersion() {\n    try {\n      const linkedinServicePath = path.join(__dirname, '../src/services/linkedin-api.ts');\n      if (fs.existsSync(linkedinServicePath)) {\n        const content = fs.readFileSync(linkedinServicePath, 'utf8');\n        const versionMatch = content.match(/API_VERSION.*['\"](.*?)['\"]/i);\n        return versionMatch ? versionMatch[1] : 'v2';\n      }\n    } catch (error) {\n      console.warn('Could not detect LinkedIn API version');\n    }\n    return 'v2';\n  }\n\n  /**\n   * Set environment variables for Vercel runtime\n   */\n  setVercelEnvVars(versionConfig) {\n    // These would be set in Vercel dashboard or via API\n    const envVars = {\n      NEXT_PUBLIC_APP_VERSION: versionConfig.version,\n      NEXT_PUBLIC_BUILD_DATE: versionConfig.buildDate,\n      NEXT_PUBLIC_COMMIT_HASH: versionConfig.commitHash,\n      NEXT_PUBLIC_FEATURES: JSON.stringify(versionConfig.features),\n    };\n\n    console.log('üìù Environment variables for Vercel:');\n    Object.entries(envVars).forEach(([key, value]) => {\n      console.log(`  ${key}=${value}`);\n    });\n  }\n\n  /**\n   * Generate deployment manifest\n   */\n  async generateDeploymentManifest(versionConfig) {\n    const manifest = {\n      version: versionConfig.version,\n      timestamp: new Date().toISOString(),\n      environment: process.env.VERCEL_ENV || 'development',\n      region: process.env.VERCEL_REGION || 'unknown',\n      commitHash: versionConfig.commitHash,\n      features: versionConfig.features,\n      dependencies: {\n        production: Object.keys(this.packageJson.dependencies).length,\n        development: Object.keys(this.packageJson.devDependencies || {}).length,\n      },\n      buildConfiguration: {\n        framework: 'nextjs',\n        nodeVersion: process.version,\n        outputDirectory: '.next',\n        buildCommand: 'npm run build',\n      },\n    };\n\n    const manifestPath = path.join(__dirname, '../public/deployment-manifest.json');\n    fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));\n    \n    console.log('üì¶ Generated deployment manifest');\n  }\n\n  /**\n   * Validate deployment by checking key endpoints\n   */\n  async validateDeployment(deploymentUrl) {\n    if (!deploymentUrl || deploymentUrl === 'localhost') {\n      console.log('‚è≠Ô∏è Skipping deployment validation (local environment)');\n      return;\n    }\n\n    console.log(`üîç Validating deployment at ${deploymentUrl}`);\n    \n    const endpoints = [\n      '/',\n      '/api/version',\n      '/api/version/api-compatibility',\n    ];\n\n    for (const endpoint of endpoints) {\n      try {\n        const response = await fetch(`https://${deploymentUrl}${endpoint}`, {\n          signal: AbortSignal.timeout(10000), // 10s timeout\n        });\n        \n        if (response.ok) {\n          console.log(`  ‚úÖ ${endpoint} - OK (${response.status})`);\n        } else {\n          console.log(`  ‚ö†Ô∏è ${endpoint} - ${response.status}`);\n        }\n      } catch (error) {\n        console.log(`  ‚ùå ${endpoint} - Failed: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Update performance metrics after deployment\n   */\n  async updatePerformanceMetrics(deploymentUrl) {\n    if (!deploymentUrl || deploymentUrl === 'localhost') {\n      console.log('‚è≠Ô∏è Skipping performance metrics (local environment)');\n      return;\n    }\n\n    console.log('üìä Updating performance metrics...');\n    \n    try {\n      // This would integrate with Lighthouse CI or other performance tools\n      const performanceData = {\n        version: this.packageJson.version,\n        timestamp: new Date().toISOString(),\n        url: `https://${deploymentUrl}`,\n        environment: process.env.VERCEL_ENV,\n        metrics: {\n          // These would be real metrics from Lighthouse or similar\n          placeholder: 'Integrate with Lighthouse CI or Core Web Vitals',\n        },\n      };\n\n      // Store performance data\n      const metricsPath = path.join(__dirname, '../docs/performance-metrics.json');\n      let metrics = [];\n      \n      if (fs.existsSync(metricsPath)) {\n        metrics = JSON.parse(fs.readFileSync(metricsPath, 'utf8'));\n      }\n      \n      metrics.push(performanceData);\n      \n      // Keep only last 50 entries\n      if (metrics.length > 50) {\n        metrics = metrics.slice(-50);\n      }\n      \n      fs.writeFileSync(metricsPath, JSON.stringify(metrics, null, 2));\n      \n      console.log('‚úÖ Performance metrics updated');\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to update performance metrics:', error.message);\n    }\n  }\n\n  /**\n   * Send deployment notifications\n   */\n  async sendDeploymentNotifications(version, deploymentUrl) {\n    console.log('üì¢ Sending deployment notifications...');\n    \n    const notificationData = {\n      version,\n      url: deploymentUrl ? `https://${deploymentUrl}` : 'local',\n      environment: process.env.VERCEL_ENV || 'development',\n      timestamp: new Date().toISOString(),\n      commitHash: this.getCommitHash(),\n    };\n\n    // Here you could integrate with:\n    // - Slack webhooks\n    // - Discord webhooks\n    // - Email services\n    // - GitHub status checks\n    // - Custom analytics\n    \n    console.log('üì® Notification data:', notificationData);\n    console.log('‚úÖ Deployment notifications sent');\n  }\n\n  /**\n   * Utility methods\n   */\n  getCommitHash() {\n    try {\n      // Try Vercel environment variable first\n      if (process.env.VERCEL_GIT_COMMIT_SHA) {\n        return process.env.VERCEL_GIT_COMMIT_SHA.substring(0, 7);\n      }\n      \n      // Fallback to git command\n      return execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim().substring(0, 7);\n    } catch (error) {\n      return 'unknown';\n    }\n  }\n\n  /**\n   * Emergency rollback functionality\n   */\n  async emergencyRollback() {\n    console.log('üö® Initiating emergency rollback...');\n    \n    try {\n      // This would integrate with Vercel's rollback API\n      console.log('Rolling back to previous deployment...');\n      \n      // Notify stakeholders\n      console.log('üì¢ Notifying stakeholders of rollback...');\n      \n      console.log('‚úÖ Emergency rollback completed');\n    } catch (error) {\n      console.error('‚ùå Emergency rollback failed:', error);\n      process.exit(1);\n    }\n  }\n}\n\n// CLI Interface\nconst hook = new VercelDeploymentHook();\nconst command = process.argv[2];\n\nasync function main() {\n  switch (command) {\n    case 'pre':\n    case 'pre-deployment':\n      await hook.preDeployment();\n      break;\n    case 'post':\n    case 'post-deployment':\n      await hook.postDeployment();\n      break;\n    case 'rollback':\n      await hook.emergencyRollback();\n      break;\n    default:\n      console.log('Usage: node vercel-deploy-hook.js [pre|post|rollback]');\n      process.exit(1);\n  }\n}\n\nif (require.main === module) {\n  main().catch(error => {\n    console.error('‚ùå Vercel deployment hook failed:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = VercelDeploymentHook;