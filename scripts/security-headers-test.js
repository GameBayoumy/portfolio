#!/usr/bin/env node

/**
 * Security Headers Testing Tool
 * Validates security headers implementation for Vercel deployment
 */

const https = require('https');
const http = require('http');

class SecurityHeadersTest {
  constructor(baseUrl = 'https://localhost:3000') {
    this.baseUrl = baseUrl.replace(/\/$/, '');
    this.testEndpoints = [
      '/',
      '/api/health-check',
      '/api/version',
      '/_next/static/test.js',
      '/fonts/test.woff2',
      '/models/test.glb'
    ];
    
    this.requiredHeaders = {
      'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
      'X-Content-Type-Options': ['nosniff'],
      'Referrer-Policy': ['strict-origin-when-cross-origin', 'no-referrer', 'same-origin'],
      'X-XSS-Protection': ['1; mode=block', '0'], // Both are acceptable
    };
    
    this.recommendedHeaders = {
      'Strict-Transport-Security': 'max-age',
      'Content-Security-Policy': 'default-src',
      'Permissions-Policy': 'camera=',
    };
  }

  /**
   * Test security headers for a specific URL
   */
  async testUrl(url) {\n    return new Promise((resolve, reject) => {\n      const requestUrl = url.startsWith('http') ? url : `${this.baseUrl}${url}`;\n      const protocol = requestUrl.startsWith('https') ? https : http;\n      \n      console.log(`🔍 Testing: ${requestUrl}`);\n      \n      const request = protocol.get(requestUrl, {\n        timeout: 10000,\n        headers: {\n          'User-Agent': 'Security-Headers-Test/1.0'\n        }\n      }, (response) => {\n        const headers = response.headers;\n        const result = {\n          url: requestUrl,\n          statusCode: response.statusCode,\n          headers: headers,\n          security: this.analyzeSecurityHeaders(headers),\n          timestamp: new Date().toISOString()\n        };\n        \n        resolve(result);\n      });\n      \n      request.on('error', (error) => {\n        reject(new Error(`Request failed for ${requestUrl}: ${error.message}`));\n      });\n      \n      request.on('timeout', () => {\n        request.destroy();\n        reject(new Error(`Timeout for ${requestUrl}`));\n      });\n    });\n  }\n\n  /**\n   * Analyze security headers\n   */\n  analyzeSecurityHeaders(headers) {\n    const analysis = {\n      score: 0,\n      maxScore: 0,\n      passed: [],\n      failed: [],\n      warnings: [],\n      recommendations: []\n    };\n\n    // Test required headers\n    for (const [headerName, acceptableValues] of Object.entries(this.requiredHeaders)) {\n      analysis.maxScore += 10;\n      const headerValue = headers[headerName.toLowerCase()];\n      \n      if (headerValue) {\n        if (Array.isArray(acceptableValues)) {\n          const isValid = acceptableValues.some(acceptable => \n            headerValue.toLowerCase().includes(acceptable.toLowerCase())\n          );\n          \n          if (isValid) {\n            analysis.passed.push({ header: headerName, value: headerValue, points: 10 });\n            analysis.score += 10;\n          } else {\n            analysis.failed.push({ \n              header: headerName, \n              value: headerValue, \n              expected: acceptableValues,\n              points: 0\n            });\n          }\n        } else {\n          if (headerValue.toLowerCase().includes(acceptableValues.toLowerCase())) {\n            analysis.passed.push({ header: headerName, value: headerValue, points: 10 });\n            analysis.score += 10;\n          } else {\n            analysis.failed.push({ \n              header: headerName, \n              value: headerValue, \n              expected: acceptableValues,\n              points: 0\n            });\n          }\n        }\n      } else {\n        analysis.failed.push({ \n          header: headerName, \n          value: null, \n          expected: acceptableValues,\n          points: 0\n        });\n      }\n    }\n\n    // Test recommended headers\n    for (const [headerName, expectedContent] of Object.entries(this.recommendedHeaders)) {\n      analysis.maxScore += 5;\n      const headerValue = headers[headerName.toLowerCase()];\n      \n      if (headerValue && headerValue.toLowerCase().includes(expectedContent.toLowerCase())) {\n        analysis.passed.push({ header: headerName, value: headerValue, points: 5 });\n        analysis.score += 5;\n      } else if (headerValue) {\n        analysis.warnings.push({ \n          header: headerName, \n          value: headerValue, \n          issue: `Should contain '${expectedContent}'`,\n          points: 2\n        });\n        analysis.score += 2;\n      } else {\n        analysis.recommendations.push({ \n          header: headerName, \n          suggestion: `Add ${headerName} header with ${expectedContent}`,\n          points: 0\n        });\n      }\n    }\n\n    // Check for dangerous headers\n    const dangerousHeaders = ['server', 'x-powered-by', 'x-aspnet-version'];\n    dangerousHeaders.forEach(header => {\n      if (headers[header]) {\n        analysis.warnings.push({\n          header,\n          value: headers[header],\n          issue: 'Exposes server information',\n          points: -2\n        });\n        analysis.score -= 2;\n      }\n    });\n\n    // Calculate percentage\n    analysis.percentage = analysis.maxScore > 0 ? Math.round((analysis.score / analysis.maxScore) * 100) : 0;\n    analysis.grade = this.calculateGrade(analysis.percentage);\n    \n    return analysis;\n  }\n\n  /**\n   * Calculate security grade\n   */\n  calculateGrade(percentage) {\n    if (percentage >= 95) return 'A+';\n    if (percentage >= 90) return 'A';\n    if (percentage >= 85) return 'A-';\n    if (percentage >= 80) return 'B+';\n    if (percentage >= 75) return 'B';\n    if (percentage >= 70) return 'B-';\n    if (percentage >= 65) return 'C+';\n    if (percentage >= 60) return 'C';\n    if (percentage >= 55) return 'C-';\n    if (percentage >= 50) return 'D';\n    return 'F';\n  }\n\n  /**\n   * Run full security test suite\n   */\n  async runFullTest() {\n    console.log(`🛡️ Starting security headers test for ${this.baseUrl}\\n`);\n    \n    const results = [];\n    const summary = {\n      totalTests: this.testEndpoints.length,\n      passed: 0,\n      failed: 0,\n      averageScore: 0,\n      overallGrade: 'F',\n      timestamp: new Date().toISOString()\n    };\n\n    for (const endpoint of this.testEndpoints) {\n      try {\n        const result = await this.testUrl(endpoint);\n        results.push(result);\n        \n        const grade = result.security.grade;\n        const score = result.security.percentage;\n        \n        console.log(`${this.getGradeEmoji(grade)} ${endpoint} - Grade: ${grade} (${score}%)`);\n        \n        if (score >= 70) {\n          summary.passed++;\n        } else {\n          summary.failed++;\n        }\n      } catch (error) {\n        console.error(`❌ ${endpoint} - Error: ${error.message}`);\n        summary.failed++;\n        results.push({\n          url: endpoint,\n          error: error.message,\n          timestamp: new Date().toISOString()\n        });\n      }\n    }\n\n    // Calculate summary\n    const validResults = results.filter(r => r.security);\n    if (validResults.length > 0) {\n      const totalScore = validResults.reduce((sum, r) => sum + r.security.percentage, 0);\n      summary.averageScore = Math.round(totalScore / validResults.length);\n      summary.overallGrade = this.calculateGrade(summary.averageScore);\n    }\n\n    this.printSummary(summary, results);\n    this.generateReport(results, summary);\n    \n    return { results, summary };\n  }\n\n  /**\n   * Get emoji for grade\n   */\n  getGradeEmoji(grade) {\n    const gradeEmojis = {\n      'A+': '🏆', 'A': '🥇', 'A-': '🥈',\n      'B+': '🥉', 'B': '✅', 'B-': '✅',\n      'C+': '⚠️', 'C': '⚠️', 'C-': '⚠️',\n      'D': '❌', 'F': '💀'\n    };\n    return gradeEmojis[grade] || '❓';\n  }\n\n  /**\n   * Print test summary\n   */\n  printSummary(summary, results) {\n    console.log(`\\n📊 Security Headers Test Summary`);\n    console.log(`${'='.repeat(50)}`);\n    console.log(`Overall Grade: ${this.getGradeEmoji(summary.overallGrade)} ${summary.overallGrade} (${summary.averageScore}%)`);\n    console.log(`Tests Passed: ${summary.passed}/${summary.totalTests}`);\n    console.log(`Tests Failed: ${summary.failed}/${summary.totalTests}`);\n    console.log(`Test Date: ${summary.timestamp}`);\n    \n    // Show detailed results for failed tests\n    const failedResults = results.filter(r => r.security && r.security.percentage < 70);\n    if (failedResults.length > 0) {\n      console.log(`\\n❌ Failed Tests Details:`);\n      failedResults.forEach(result => {\n        console.log(`\\n🔍 ${result.url} (${result.security.grade} - ${result.security.percentage}%)`);\n        \n        if (result.security.failed.length > 0) {\n          console.log('  Missing/Invalid Headers:');\n          result.security.failed.forEach(failure => {\n            console.log(`    ❌ ${failure.header}: ${failure.value || 'MISSING'}`);\n          });\n        }\n        \n        if (result.security.recommendations.length > 0) {\n          console.log('  Recommendations:');\n          result.security.recommendations.forEach(rec => {\n            console.log(`    💡 ${rec.suggestion}`);\n          });\n        }\n      });\n    }\n    \n    console.log(`\\n${'='.repeat(50)}`);\n  }\n\n  /**\n   * Generate detailed report\n   */\n  generateReport(results, summary) {\n    const report = {\n      summary,\n      results,\n      recommendations: this.generateRecommendations(results),\n      generatedAt: new Date().toISOString()\n    };\n\n    const reportPath = `security-headers-report-${Date.now()}.json`;\n    require('fs').writeFileSync(reportPath, JSON.stringify(report, null, 2));\n    console.log(`📄 Detailed report saved: ${reportPath}`);\n  }\n\n  /**\n   * Generate recommendations based on test results\n   */\n  generateRecommendations(results) {\n    const recommendations = [];\n    const commonIssues = {};\n    \n    results.forEach(result => {\n      if (result.security) {\n        result.security.failed.forEach(failure => {\n          const key = failure.header;\n          commonIssues[key] = (commonIssues[key] || 0) + 1;\n        });\n        \n        result.security.recommendations.forEach(rec => {\n          const key = rec.header;\n          commonIssues[key] = (commonIssues[key] || 0) + 1;\n        });\n      }\n    });\n    \n    // Generate recommendations for common issues\n    Object.entries(commonIssues).forEach(([header, count]) => {\n      if (count >= 2) {\n        recommendations.push({\n          priority: 'high',\n          header,\n          issue: `Missing or incorrect in ${count} endpoints`,\n          solution: this.getHeaderSolution(header),\n          affectedEndpoints: count\n        });\n      }\n    });\n    \n    return recommendations;\n  }\n\n  /**\n   * Get solution for specific header\n   */\n  getHeaderSolution(header) {\n    const solutions = {\n      'X-Frame-Options': 'Add to vercel.json headers: {\"key\": \"X-Frame-Options\", \"value\": \"DENY\"}',\n      'X-Content-Type-Options': 'Add to vercel.json headers: {\"key\": \"X-Content-Type-Options\", \"value\": \"nosniff\"}',\n      'Referrer-Policy': 'Add to vercel.json headers: {\"key\": \"Referrer-Policy\", \"value\": \"strict-origin-when-cross-origin\"}',\n      'Strict-Transport-Security': 'Add to vercel.json headers: {\"key\": \"Strict-Transport-Security\", \"value\": \"max-age=63072000; includeSubDomains; preload\"}',\n      'Content-Security-Policy': 'Add comprehensive CSP header to vercel.json',\n      'Permissions-Policy': 'Add to vercel.json headers with appropriate permissions'\n    };\n    \n    return solutions[header] || `Configure ${header} header in vercel.json`;\n  }\n}\n\n// CLI Interface\nconst baseUrl = process.argv[2] || 'http://localhost:3000';\nconst securityTest = new SecurityHeadersTest(baseUrl);\n\nasync function main() {\n  try {\n    await securityTest.runFullTest();\n  } catch (error) {\n    console.error('❌ Security test failed:', error.message);\n    process.exit(1);\n  }\n}\n\nif (require.main === module) {\n  main();\n}\n\nmodule.exports = SecurityHeadersTest;